% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazytensor_operations.R
\name{default.arithmetic.fun}
\alias{default.arithmetic.fun}
\alias{+.default}
\alias{-.default}
\alias{*.default}
\alias{/.default}
\alias{^.default}
\title{Default arithmetic operations}
\usage{
## Default S3 method:
\special{+x}
\special{x + y}

## Default S3 method:
\special{-x}
\special{x - y}

\method{*}{default}(x, y)

\method{/}{default}(x, y)

\method{^}{default}(x, y)
}
\arguments{
\item{x, y}{numeric or complex vectors or objects which can be
    coerced to such, or other objects for which methods have been written.}
}
\value{
Unary \code{+} and unary \code{-} return a numeric or complex vector.
  All attributes (including class) are preserved if there is no
  coercion: logical \code{x} is coerced to integer and names, dims and
  dimnames are preserved.

  The binary operators return vectors containing the result of the element
  by element operations.  If involving a zero-length vector the result
  has length zero.  Otherwise, the elements of shorter vectors are recycled
  as necessary (with a \code{\link[base]{warning}} when they are recycled only
  \emph{fractionally}).  The operators are \code{+} for addition,
  \code{-} for subtraction, \code{*} for multiplication, \code{/} for
  division and \code{^} for exponentiation.

  \code{\%\%} indicates \code{x mod y} (\dQuote{x modulo y}), i.e.,
  computes the \sQuote{remainder} \code{r <- x \%\% y}, and
  \code{\%/\%} indicates integer division, where \R uses \dQuote{floored}
  integer division, i.e., \code{q <- x \%/\% y := floor(x/y)}, as promoted
  by Donald Knuth, see the Wikipedia page on \sQuote{Modulo operation},
  and hence \code{sign(r) == sign(y)}.  It is guaranteed that
  \describe{
    \item{\code{ x == (x \%\% y) + y * (x \%/\% y) }}{\ifelse{latex}{\out{~}}{ } (up to rounding error)}
  }
  unless \code{y == 0} where the result of \code{\%\%} is
  \code{\link[base]{NA_integer_}} or \code{\link[base]{NaN}} (depending on the
  \code{\link[base]{typeof}} of the arguments) or for some non-\link[base]{finite}
  arguments, e.g., when the RHS of the identity above
  amounts to \code{Inf - Inf}.

  If either argument is complex the result will be complex, otherwise if
  one or both arguments are numeric, the result will be numeric.  If
  both arguments are of type \link[base]{integer}, the type of the result of
  \code{/} and \code{^} is \link[base]{numeric} and for the other operators it
  is integer (with overflow, which occurs at
  \eqn{\pm(2^{31} - 1)}{+/- (2^31 - 1)},
  returned as \code{NA_integer_} with a warning).

  The rules for determining the attributes of the result are rather
  complicated.  Most attributes are taken from the longer argument.
  Names will be copied from the first if it is the same length as the
  answer, otherwise from the second if that is.  If the arguments are
  the same length, attributes will be copied from both, with those of
  the first argument taking precedence when the same attribute is
  present in both arguments. For time series, these operations are
  allowed only if the series are compatible, when the class and
  \code{\link{tsp}} attribute of whichever is a time series (the same,
  if both are) are used.  For arrays (and an array result) the
  dimensions and dimnames are taken from first argument if it is an
  array, otherwise the second.
}
\description{
These unary and binary operators perform arithmetic on numeric or
  complex vectors (or objects which can be coerced to them).
}
\details{
The unary and binary arithmetic operators are generic functions:
  methods can be written for them individually or via the
  \code{\link[base:S3groupGeneric]{Ops}} group generic function.  (See
  \code{\link[base:S3groupGeneric]{Ops}} for how dispatch is computed.)

  If applied to arrays the result will be an array if this is sensible
  (for example it will not if the recycling rule has been invoked).

  Logical vectors will be coerced to integer or numeric vectors,
  \code{FALSE} having value zero and \code{TRUE} having value one.

  \code{1 ^ y} and \code{y ^ 0} are \code{1}, \emph{always}.
  \code{x ^ y} should also give the proper limit result when
  either (numeric) argument is \link[base]{infinite} (one of \code{Inf} or
  \code{-Inf}).

  Objects such as arrays or time-series can be operated on this
  way provided they are conformable.

  For double arguments, \code{\%\%} can be subject to catastrophic loss of
  accuracy if \code{x} is much larger than \code{y}, and a warning is
  given if this is detected.

  \code{\%\%} and \code{x \%/\% y} can be used for non-integer \code{y},
  e.g.\ifelse{latex}{\out{~}}{ }{}\code{1 \%/\% 0.2}, but the results are subject to representation
  error and so may be platform-dependent.  Because the IEC 60559
  representation of \code{0.2} is a binary fraction slightly larger than
  \code{0.2}, the answer to \code{1 \%/\% 0.2} should be \code{4} but
  most platforms give \code{5}.

  Users are sometimes surprised by the value returned, for example why
  \code{(-8)^(1/3)} is \code{NaN}.  For \link[base]{double} inputs, \R makes
  use of IEC 60559 arithmetic on all platforms, together with the C
  system function \samp{pow} for the \code{^} operator.  The relevant
  standards define the result in many corner cases.  In particular, the
  result in the example above is mandated by the C99 standard.  On many
  Unix-alike systems the command \command{man pow} gives details of the
  values in a large number of corner cases.

  Arithmetic on type \link[base]{double} in \R is supposed to be done in
  \sQuote{round to nearest, ties to even} mode, but this does depend on
  the compiler and FPU being set up correctly.
}
\examples{
x <- -1:12
x + 1
2 * x + 3
x \%\%  3 # is periodic  2 0  1  2 0  1 ...
x \%\% -3 #  (ditto)    -1 0 -2 -1 0 -2 ...
x \%/\% 5
x \%\% Inf # now is defined by limit (gave NaN in earlier versions of R)
}
\seealso{
\link[base:Arithmetic]{base::Arithmetic}
}
\author{
R core team and contributors
}
